PercentUpTimeAdvanced Algorithm

 PercentUpTimeAdvanced calculates the percentage uptime of a system based on a sequence of numeric data points, handling gaps (missing data) and counter resets robustly.

Algorithm Steps

 
 Gradient Calculation: Average the difference between consecutive increasing values (ignoring resets).

 
 Gap & Downtime Detection:
 
 Nulls are counted as downtime.

 Counter resets (value decreases) are ignored for downtime.

 Large jumps (greater than expected by gradient Ã— 1.1) are counted as gaps/downtime.

 For gaps, downtime includes both the missing points and partial downtime before the gap started.

 
 

 Uptime Percentage: (uptime / total expected) * 100

 

Example 1: Simple Sequence with a Gap

 Input: [1, 2, 3, null, 4, 5]

 Gradient Calculation: (2-1)+(3-2)+(4-3)+(5-4) = 4; Average = 1

 Gap Detection: Null at index 3 is downtime (1 point).

 Uptime Calculation: 5 actual points + 1 null = 6 total; 1 downtime; Uptime = 5/6 = 83.33%
 
 
 
 
 
 
 
 
 
 1
 2
 3
 null
 4
 5
 
 Blue: data points; Red: gap/null

 

Example 2: Sequence with Counter Reset

 Input: [1, 2, 3, 4, 1, 2, 3]

 Gradient Calculation: Only increasing pairs: (2-1), (3-2), (4-3), (2-1), (3-2) = 1,1,1,1,1; Average = 1

 Counter Reset: 4 to 1 is a reset, not a gap.

 Uptime Calculation: All 7 points present, no gaps; Uptime = 7/7 = 100%
 
 
 
 
 
 
 
 
 
 
 1
 2
 3
 4
 1
 2
 3
 
 Blue: data points; Reset shown by drop from 4 to 1

 

Example 3: Sequence with Jump/Gaps

 Input: [1, 2, 3, 10, 11]

 Gradient Calculation: (2-1), (3-2), (10-3), (11-10) = 1,1,7,1; Average = 2.5

 Gap Detection: Jump from 3 to 10 detected; gap = 2, projectedStart = 2.5, downtimeForGap = 2.

 Uptime Calculation: 5 actual points + 2 gap points = 7 total; 2 downtime; Uptime = 5/7 = 71.43%
 
 
 
 
 
 
 
 
 
 1
 2
 3
 gap
 10
 11
 
 Blue: data points; Red: gap/jump

 

Example 4: Multiple Gaps and Counter Reset

 Input: [1, 2, null, 3, 10, null, 11, 1, 2, null, 3]

 Gradient Calculation: Only increasing pairs: (2-1), (3-2), (10-3), (11-10), (2-1), (3-2) = 1,1,7,1,1,1; Average = 2

 Gap Detection: 
 
 Null at index 2: 1 downtime

 Jump from 3 to 10: gap = 3, downtimeForGap = 3

 Null at index 5: 1 downtime

 Reset from 11 to 1: not counted as gap

 Null at index 9: 1 downtime

 
 Uptime Calculation: 8 actual points + 6 gap/null points = 14 total; 6 downtime; Uptime = 8/14 = 57.14%
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 1
 2
 null
 3
 gap
 10
 null
 11
 1
 2
 null
 3
 
 Blue: data points; Red: gap/null; Reset shown by drop from 11 to 1

 

Example 5: Long Sequence with Multiple Jumps and Resets

 Input: [5, 6, 7, 20, null, 21, 22, 5, 6, 7, 8, 30, 31, null, 32]

 Gradient Calculation: Increasing pairs: (6-5), (7-6), (20-7), (21-20), (22-21), (6-5), (7-6), (8-7), (30-8), (31-30), (32-31) = 1,1,13,1,1,1,1,1,22,1,1; Average = 4.0

 Gap Detection:
 
 Jump from 7 to 20: gap = 2, downtimeForGap = 2

 Null at index 4: 1 downtime

 Reset from 22 to 5: not counted as gap

 Jump from 8 to 30: gap = 5, downtimeForGap = 5

 Null at index 13: 1 downtime

 
 Uptime Calculation: 13 actual points + 9 gap/null points = 22 total; 9 downtime; Uptime = 13/22 = 59.09%
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 5
 6
 7
 gap
 20
 null
 21
 22
 5
 6
 7
 8
 gap
 30
 31
 null
 32
 
 Blue: data points; Red: gap/null; Resets shown by drops

 

Algorithm Code Snippet (C#)

 
private static double CalculatePercentUptimeGradient(List values)
{
 double gradientSum = 0;
 int gradientCount = 0;
 double? prev = null;
 for (int i = 0; i prev.Value)
 {
 gradientSum += v - prev.Value;
 gradientCount++;
 }
 prev = v;
 }
 }
 return gradientCount > 0 ? gradientSum / gradientCount : 0;
}

private static (int totalDowntime, int totalExpectedDataPoints) CalculateDowntime(List values, double gradient)
{
 int totalDowntime = 0;
 int totalExpectedDataPoints = 0;
 double? previousValue = null;
 for (int i = 0; i previousValue.Value && Math.Abs(doubleValue - expectedNext) > gradient * 1.1)
 {
 int gap = (int)Math.Round((doubleValue - previousValue.Value) / gradient) - 1;
 if (gap > 0)
 {
 double projectedStart = doubleValue - gap * gradient - gradient;
 int downtimeForGap = gap + (int)Math.Round((previousValue.Value - projectedStart) / gradient);
 totalDowntime += downtimeForGap;
 totalExpectedDataPoints += gap;
 }
 }
 }
 previousValue = doubleValue;
 }
 else
 {
 totalDowntime++;
 totalExpectedDataPoints++;
 }
 }
 totalExpectedDataPoints += values.Count(v => v is double);
 return (totalDowntime, totalExpectedDataPoints);
}

// Usage in aggregation:
if (values.Count == 0 || values.All(v => v is null))
{
 return null;
}
var doubleValues = values.Select(v => v as double?).ToList();
double gradient = CalculatePercentUptimeGradient(doubleValues);
if (Math.Abs(gradient)
